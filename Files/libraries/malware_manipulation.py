import os, sys, hashlib
from termcolor import colored
import math
import pefile, magic
import binascii, subprocess
from capstone import *

def open_file(name, mode):
    file = open(name, mode)
    if file.closed:
        print("Could not open {name}".format(name=name))
        sys.exit(1)
    return file

def copy_file(file, readMode, writeMode, copyName):
    original = open_file(file, readMode)
    copy = open_file(copyName, writeMode)
    copy.write(original.read())
    original.close()
    copy.close()


class append:
    def __init__(self, temp_dir):
        self.temp_dir = temp_dir
        if not os.path.exists(temp_dir):
            os.system("mkdir " + temp_dir)

    def __repr(self):
        return self.temp_dir

    def calculate_md5(self, file_name):
        file = self.open_file(file_name, "rb")
        md5_hash = hashlib.md5()
        for byte_block in iter(lambda: file.read(4096), b""):
            md5_hash.update(byte_block)
        file.close()
        return md5_hash.hexdigest()

    def open_file(self, name, mode):
        file = open(name, mode)
        if file.closed:
            print("Could not open {name}".format(name=name))
            sys.exit(1)
        return file
    
    def add_bytes(self, file):
        md5_hash = self.calculate_md5(file)    
        
        file = self.open_file(file, "rb")
        size = 50
        result = os.urandom(size)
        
        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="original")
        if(not os.path.exists(name)):
            md5_original = self.open_file(name, "xb")
            md5_original.write(file.read())
            md5_original.close()
            file.seek(0)

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="byte")
        md5_byte = self.open_file(name, "xb")
        md5_byte.write(file.read())
        md5_byte.write(result)
        md5_byte.close()

        file.close()

    #arquivo1 = arquivo para extração de strings
    #arquivo2 = arquivo que recebera o append
    def add_strings(self, file1, file2):
        strings = os.popen("strings {goodware}".format(goodware=file1)).read()
        strings = list(strings.split("\n"))
        
        md5_hash = self.calculate_md5(file2)    
        file2 = self.open_file(file2, "rb")

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="original")
        if(not os.path.exists(name)):
            md5_original = self.open_file(name, "xb")
            md5_original.write(file2.read())
            md5_original.close()
            file2.seek(0)

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="string")
        md5_string = self.open_file(name, "xb")
        md5_string.write(file2.read())
        md5_string.close()
        md5_string = self.open_file(name, "a")
        for string in strings:
            md5_string.write(string)
        md5_string.close()

        file2.close()

class disassemble:
    def __init__(self, temp_dir):
        self.temp_dir = temp_dir
    '''
        Flags that indicate execuble code in section's characteristics:
            0x00000020 = Section contains code
            0x20000000 = Section is executable
    '''
    def isExecutable(self, section):
        flag = getattr(section, "Characteristics")
        if flag & 0x00000020 > 0 or flag & 0x20000000 > 0:
            return True
        return False

    def get_executable_sections(self, pe):
        executables = []
        for section in pe.sections:
            if self.isExecutable(section):
                executables.append(section)
        return executables

    def get_CS_mode(self, path):
        data = magic.from_file(path)
        data = data.split(" ")
        if data[0] == "PE32":
            return CS_MODE_32
        return CS_MODE_64

    def print_disasm(self, path):
        disasm = self.disasm(path)
        for i in disasm:
            print("0x%i:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))

    def get_int3_amount(self, path):
        disasm = self.disasm(path)
        int3 = {}
        for i in disasm:
            if i.mnemonic == "int3":
                int3[i.address] = i.mnemonic
        return len(int3)

    def count_nops_bellow_ret(self, disasmList, index):
        i = index + 1
        count = 0
        while i < len(disasmList) and disasmList[i].count("nop"):
            count = count + 1
            i = i + 1
        return count

    def get_ret(self, path, offset):
        disasm, sizes, bArray = self.convert_disasm_to_list(path)
        retDict = []

        i = 0
        while i < len(disasm):
            if disasm[i].count("ret"):
                nopAmount = self.count_nops_bellow_ret(disasm, i)
                if nopAmount != 0:
                    bytePatternOrig = bytearray(b'')
                    bytePatternMod = bytearray(b'')
                    for j in range(offset, 0, -1):
                        bytePatternOrig.extend(bArray[i-j])
                        bytePatternMod.extend(bArray[i-j])
                    
                    for j in range(nopAmount + 1):
                        if j != 0:
                            bytePatternMod.extend(bArray[i+j])
                        bytePatternOrig.extend(bArray[i+j])
                    bytePatternMod.extend(bArray[i])

                    retDict.append((bytes(bytePatternOrig), bytes(bytePatternMod)))

            i = i + 1
        return retDict
        
    def swap_ret_nop(self, malware, offset):
        md5_hash = append(self.temp_dir).calculate_md5(malware)
        file = open_file(malware, "rb")

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="original")
        if(not os.path.exists(name)):
            md5_original = open_file(name, "xb")
            md5_original.write(file.read())
            md5_original.close()
            file.seek(0)
        file.close()

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="swap")
        copy_file(malware, "rb", "wb", name)
        retList = self.get_ret(malware, offset)
        for i in range(len(retList)):
            self.file_replace(name, retList[i][0], retList[i][1])
        # self.diff_disasm(malware, name)

    def disasm(self, path):
        pe = pefile.PE(path)
        executables = self.get_executable_sections(pe)
        
        for executable  in executables:
            data = pe.get_data(executable.VirtualAddress) # one way to get_data from section
            mode = self.get_CS_mode(path)
            caps = Cs(CS_ARCH_X86, mode)
            disasm = caps.disasm(data, 0x1000)

        return disasm

    def convert_disasm_to_list(self, path):
        disasm = self.disasm(path)
        l = []
        instructionSizes =[]
        bytearrays = []
        for i in disasm:
            line = "0x{:<8}{:<8}{:<14}".format(str(i.address) + ":", i.mnemonic, i.op_str)
            l.append(line)
            instructionSizes.append(i.size)
            bytearrays.append(i.bytes)
        return l, instructionSizes, bytearrays

    def diff_disasm(self, path1, path2):
        disasmOriginal, originalInstSizes, barrayOrig = self.convert_disasm_to_list(path1)
        disasmModificado, modifiedInstSizes, barrayMod = self.convert_disasm_to_list(path2)

        malwareName = colored("{:<50}", "green").format(path1)
        malwareCpyName = colored("{:^25}", "red").format(path2)
        print("{malware}|{malwareCpy}".format(malware=malwareName, malwareCpy=malwareCpyName))
        
        i = 0
        j = 0
        while j < len(disasmModificado):
            output = "{:<50}|\t{:<20}".format(disasmOriginal[i], disasmModificado[j])
            
            if disasmOriginal[i] == disasmModificado[j]:
                if j+1 < len(disasmModificado) and disasmOriginal[i+1] != disasmModificado[j+1]:
                    print(output)
                elif  j-1 > 0 and disasmOriginal[i-1] != disasmModificado[j-1]:
                    print(output)
                    print("\n")
                i+=1
            else:
                print(output)
                if not disasmOriginal[i].count("ret") and not disasmModificado[i].count("ret"):
                    for offset in range(modifiedInstSizes[j] - 1):
                        print("{:<50}|\t".format(disasmOriginal[i+offset+1]))
                    i+=modifiedInstSizes[j]
                else:
                    i+=1
            j+=1

    def file_replace(self, fileName, opc1, opc2):
        file = open_file(fileName, "r+b")
        data = file.read()
        data = data.replace(opc1, opc2)
        file.seek(0)
        file.write(data)
        file.close()

    def get_bytes_nop(self, amount):
        #byteSize == 1 so amount == amount of int3
        return bytes.fromhex('90'*amount), amount
    
    def get_bytes_int3(self, amount):
        #byteSize == 1 so amount == amount of int3
        return bytes.fromhex("CC"*amount)

    def get_bytes_add_sub(self, amount):
        byteSize = 8
        amount = amount//byteSize
        return bytes.fromhex("83 45 FC 01 83 6D FC 01"*amount), amount*byteSize

    def replace_int3_addSub(self, malware):
        '''
            int3 opcode = 0xCC
            nop opcode = 0x90
        '''
        md5_hash = append(self.temp_dir).calculate_md5(malware)
        file = open_file(malware, "rb")

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="original")
        if(not os.path.exists(name)):
            md5_original = open_file(name, "xb")
            md5_original.write(file.read())
            md5_original.close()
            file.seek(0)
        file.close()

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="addSub")
        copy_file(malware, "rb", "wb", name)
        amount = self.get_int3_amount(malware)
        bytes2, usableINT3 = self.get_bytes_add_sub(amount)
        bytes1 = self.get_bytes_int3(usableINT3)
        self.file_replace(name, bytes1, bytes2)
    
        # self.diff_disasm(malware, name)

    def append_goodware_sections(self, malware, goodware):
        md5_hash = append(self.temp_dir).calculate_md5(malware)
        file = open_file(malware, "rb")

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="original")
        if(not os.path.exists(name)):
            md5_original = open_file(name, "xb")
            md5_original.write(file.read())
            md5_original.close()
            file.seek(0)
        file.close()

        name = "{dir}/{name}.{extension}".format(dir=self.temp_dir, name=md5_hash, extension="gwa")
        copy_file(malware, "rb", "wb", name)
       
        python_command = "python libraries/injection.py " + name + " " + goodware
        subprocess.run(python_command.split())
